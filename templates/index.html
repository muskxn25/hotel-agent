<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hilton Charlotte Airport - Virtual Front Desk</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #e8f4f8;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-container {
            width: 95%;
            max-width: 1100px;
            height: 90vh;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .header {
            background: white;
            color: #1e293b;
            padding: 25px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 3px solid #0891b2;
        }

        .header-left h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #0891b2;
        }

        .header-left p {
            font-size: 13px;
            color: #64748b;
        }

        .header-right {
            display: flex;
            gap: 12px;
        }

        .header-btn {
            background: #f1f5f9;
            border: 1px solid #cbd5e1;
            color: #1e293b;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .header-btn:hover {
            background: #e2e8f0;
            border-color: #0891b2;
            transform: translateY(-1px);
        }

        .header-btn.voice-active {
            background: #dc2626;
            color: white;
            border-color: #991b1b;
            animation: pulse 2s infinite;
        }
        
        .header-btn.call-btn {
            background: #10b981;
            color: white;
            border-color: #059669;
        }
        
        .header-btn.call-btn:hover {
            background: #059669;
        }
        
        .header-btn.call-active {
            background: #dc2626;
            color: white;
            border-color: #991b1b;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Messages Area */
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            background: #f8fafc;
        }

        .message {
            margin-bottom: 24px;
            display: flex;
            flex-direction: column;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 13px;
            font-weight: 600;
        }

        .message-avatar {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .message.user .message-header {
            justify-content: flex-end;
        }

        .message.user .message-avatar {
            background: #0891b2;
            color: white;
        }

        .message.agent .message-avatar {
            background: #64748b;
            color: white;
        }

        .message.user .message-label {
            color: #0891b2;
            font-weight: 600;
        }

        .message.agent .message-label {
            color: #64748b;
            font-weight: 600;
        }

        .message-bubble {
            max-width: 75%;
            padding: 16px 20px;
            border-radius: 16px;
            line-height: 1.6;
            font-size: 15px;
        }

        .message.user .message-bubble {
            background: #0891b2;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
            box-shadow: 0 2px 8px rgba(8, 145, 178, 0.2);
        }

        .message.agent .message-bubble {
            background: white;
            color: #1e293b;
            align-self: flex-start;
            border-bottom-left-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
        }

        .message.agent .message-bubble strong {
            color: #0f172a;
            font-weight: 600;
        }

        /* Typing Indicator */
        .typing-indicator {
            display: none;
            padding: 16px 20px;
            background: white;
            border-radius: 16px;
            border-bottom-left-radius: 4px;
            max-width: 80px;
            align-self: flex-start;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
        }

        .typing-indicator.active {
            display: flex;
            gap: 6px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #94a3b8;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        /* Input Area */
        .input-area {
            padding: 20px 30px;
            background: white;
            border-top: 1px solid #e2e8f0;
        }

        .input-wrapper {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .input-field {
            flex: 1;
            padding: 14px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 15px;
            font-family: inherit;
            transition: all 0.2s;
            background: #f8fafc;
        }

        .input-field:focus {
            outline: none;
            border-color: #0891b2;
            background: white;
            box-shadow: 0 0 0 3px rgba(8, 145, 178, 0.1);
        }

        .send-btn {
            padding: 14px 28px;
            background: #0891b2;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .send-btn:hover {
            background: #0e7490;
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(8, 145, 178, 0.3);
        }

        .send-btn:active {
            transform: translateY(0);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Status Bar */
        .status-bar {
            padding: 12px 30px;
            background: #f8fafc;
            border-top: 1px solid #e2e8f0;
            font-size: 12px;
            color: #64748b;
            text-align: center;
        }

        /* Booking Widget */
        .booking-widget {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 16px;
            padding: 24px;
            margin-top: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .booking-widget h3 {
            font-size: 18px;
            color: #1e293b;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .widget-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 20px;
        }

        .widget-field {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .widget-field label {
            font-size: 13px;
            font-weight: 600;
            color: #475569;
        }

        .widget-field input,
        .widget-field select {
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s;
            background: #f8fafc;
        }

        .widget-field input:focus,
        .widget-field select:focus {
            outline: none;
            border-color: #0891b2;
            background: white;
            box-shadow: 0 0 0 3px rgba(8, 145, 178, 0.1);
        }

        .widget-field.full-width {
            grid-column: 1 / -1;
        }

        .widget-actions {
            display: flex;
            gap: 12px;
        }

        .widget-btn {
            flex: 1;
            padding: 14px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .widget-btn.primary {
            background: #0891b2;
            color: white;
        }

        .widget-btn.primary:hover {
            background: #0e7490;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(8, 145, 178, 0.3);
        }

        .widget-btn.secondary {
            background: #f1f5f9;
            color: #475569;
            border: 1px solid #cbd5e1;
        }

        .widget-btn.secondary:hover {
            background: #e2e8f0;
        }

        .widget-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .widget-summary {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 16px;
            margin: 16px 0;
        }

        .widget-summary-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 14px;
        }

        .widget-summary-row.total {
            border-top: 2px solid #e2e8f0;
            margin-top: 8px;
            padding-top: 12px;
            font-weight: 600;
            font-size: 16px;
            color: #0891b2;
        }

        /* Calling Screen */
        .calling-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .calling-screen {
            background: white;
            border-radius: 24px;
            padding: 48px;
            max-width: 450px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            animation: slideUp 0.4s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .calling-avatar {
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, #0891b2, #0e7490);
            border-radius: 50%;
            margin: 0 auto 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 64px;
            position: relative;
        }

        .calling-avatar.speaking::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 3px solid #0891b2;
            animation: ripple 1.5s infinite;
        }

        @keyframes ripple {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(1.3);
                opacity: 0;
            }
        }

        .calling-name {
            font-size: 28px;
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 8px;
        }

        .calling-status {
            font-size: 16px;
            color: #64748b;
            margin-bottom: 32px;
        }

        .calling-status.active {
            color: #10b981;
            font-weight: 600;
        }

        .calling-transcript {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            margin: 24px 0;
            min-height: 80px;
            max-height: 200px;
            overflow-y: auto;
            text-align: left;
        }

        .transcript-line {
            margin: 12px 0;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
        }

        .transcript-line.user {
            background: #e0f2fe;
            color: #0c4a6e;
        }

        .transcript-line.ai {
            background: #f0fdf4;
            color: #14532d;
        }

        .transcript-line.human {
            background: #fef3c7;
            color: #78350f;
        }

        .calling-controls {
            display: flex;
            gap: 16px;
            justify-content: center;
        }

        .call-btn-large {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            font-size: 32px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .call-btn-large.end-call {
            background: #dc2626;
            color: white;
        }

        .call-btn-large.end-call:hover {
            background: #991b1b;
            transform: scale(1.1);
        }

        .call-btn-large.mute {
            background: #64748b;
            color: white;
        }

        .call-btn-large.mute:hover {
            background: #475569;
        }

        .call-btn-large.mute.active {
            background: #f59e0b;
        }

        /* Scrollbar Styling */
        .messages-container::-webkit-scrollbar {
            width: 8px;
        }

        .messages-container::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        .messages-container::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .messages-container::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Welcome Message */
        .welcome-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 16px;
            margin-bottom: 24px;
            text-align: center;
        }

        .welcome-card h2 {
            font-size: 22px;
            margin-bottom: 12px;
        }

        .welcome-card p {
            font-size: 14px;
            opacity: 0.9;
            line-height: 1.6;
        }

        /* Quick Options */
        .quick-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
        }

        .option-btn {
            background: white;
            border: 2px solid #e2e8f0;
            color: #1e293b;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            font-weight: 500;
        }

        .option-btn:hover {
            background: #0891b2;
            color: white;
            border-color: #0891b2;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(8, 145, 178, 0.2);
        }

        .option-btn:active {
            transform: translateY(0);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .chat-container {
                width: 100%;
                height: 100vh;
                border-radius: 0;
            }

            .header {
                flex-direction: column;
                gap: 12px;
                text-align: center;
            }

            .header-right {
                width: 100%;
                justify-content: center;
            }

            .message-bubble {
                max-width: 85%;
            }

            .messages-container {
                padding: 20px 15px;
            }

            .input-area {
                padding: 15px;
            }

            .quick-options {
                flex-direction: column;
            }

            .option-btn {
                width: 100%;
            }
        }
    </style>
    <!-- VAPI Web SDK for voice calls -->
    <script src="https://cdn.jsdelivr.net/npm/@vapi-ai/web@latest/dist/index.js" 
            onload="console.log('‚úÖ VAPI SDK loaded')" 
            onerror="console.error('‚ùå VAPI SDK failed to load')"></script>
    <script src="https://cdn.jsdelivr.net/npm/@vapi-ai/web@2.1.8/dist/index.umd.js" 
            onload="console.log('‚úÖ VAPI SDK backup loaded')" 
            onerror="console.error('‚ùå VAPI SDK backup failed')"></script>
</head>
<body>
    <div class="chat-container">
        <!-- Header -->
        <div class="header">
            <div class="header-left">
                <h1>Hilton Charlotte Airport</h1>
                <p>Virtual Front Desk ‚Ä¢ Available 24/7 ‚Ä¢ Airport Shuttle Available</p>
            </div>
            <div class="header-right">
                <button class="header-btn call-btn" id="callBtn" onclick="startVoiceCall()">
                    üìû Call Support
                </button>
                <button class="header-btn" id="voiceBtn" onclick="toggleVoiceMode()">
                    üé§ Voice Mode
                </button>
                <button class="header-btn" onclick="clearChat()">
                    üóëÔ∏è Clear
                </button>
            </div>
        </div>

        <!-- Messages -->
        <div class="messages-container" id="chatContainer">
            <!-- Messages will be added here -->
        </div>

        <!-- Input Area -->
        <div class="input-area">
            <div class="input-wrapper">
                <input 
                    type="text" 
                    class="input-field" 
                    id="userInput" 
                    placeholder="Ask about rooms, amenities, policies..."
                    onkeypress="handleKeyPress(event)"
                />
                <button class="send-btn" onclick="sendMessage()">
                    Send
                </button>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar" id="statusBar">
            Connected ‚Ä¢ Ready to assist
        </div>
    </div>

    <script>
        let isVoiceMode = false;
        let recognition = null;
        let synthesis = window.speechSynthesis;
        let sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        let vapiInstance = null;
        let isCallActive = false;

        // Initialize VAPI with retry
        async function initializeVapi() {
            let retries = 0;
            const maxRetries = 5;
            
            while (retries < maxRetries) {
                if (typeof Vapi !== 'undefined') {
                    try {
                        const response = await fetch('/api/vapi/public-key');
                        if (response.ok) {
                            const data = await response.json();
                            if (data.configured && data.public_key) {
                                vapiInstance = new Vapi(data.public_key);
                                setupVapiListeners();
                                console.log('‚úÖ VAPI initialized successfully');
                                return true;
                            }
                        }
                    } catch (error) {
                        console.log('VAPI initialization attempt failed:', error);
                    }
                    break;
                }
                
                // Wait and retry if Vapi not loaded yet
                await new Promise(resolve => setTimeout(resolve, 500));
                retries++;
            }
            
            console.log('‚ö†Ô∏è VAPI not available');
            return false;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await loadGreeting();
            
            // Initialize VAPI (async, with retries)
            setTimeout(() => initializeVapi(), 1000);
            
            // Initialize speech recognition if available
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = false;
                recognition.lang = 'en-US';

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    document.getElementById('userInput').value = transcript;
                    sendMessage();
                };

                recognition.onerror = (event) => {
                    updateStatus('Voice recognition error: ' + event.error);
                    stopVoiceMode();
                };

                recognition.onend = () => {
                    if (isVoiceMode) {
                        setTimeout(() => recognition.start(), 500);
                    }
                };
            } else {
                document.getElementById('voiceBtn').disabled = true;
                document.getElementById('voiceBtn').title = 'Voice mode not supported';
            }
        });

        async function loadGreeting() {
            try {
                const response = await fetch('/api/greeting');
                const data = await response.json();
                if (data.success) {
                    addMessage('agent', data.message, true);  // Show options on greeting
                }
            } catch (error) {
                console.error('Error loading greeting:', error);
                addMessage('agent', 'Welcome to Grand Plaza Hotel! How may I assist you today?', true);
            }
        }

        async function sendMessage() {
            const input = document.getElementById('userInput');
            const message = input.value.trim();

            if (!message) return;

            // Add user message
            addMessage('user', message);
            input.value = '';

            // Show typing indicator
            showTypingIndicator();

            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        message,
                        session_id: sessionId 
                    }),
                });

                const data = await response.json();
                hideTypingIndicator();

                if (data.success) {
                    addMessage('agent', data.message);
                    
                    // Speak response if voice mode is active
                    if (isVoiceMode) {
                        speakText(data.message);
                    }
                } else {
                    addMessage('agent', 'I apologize, but I encountered an error. Please try again.');
                }
            } catch (error) {
                hideTypingIndicator();
                console.error('Error:', error);
                addMessage('agent', 'I apologize, but I\'m having trouble connecting. Please try again.');
            }
        }

        function addMessage(sender, content, showOptions = false) {
            const container = document.getElementById('chatContainer');
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;

            const headerDiv = document.createElement('div');
            headerDiv.className = 'message-header';

            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = sender === 'user' ? 'üë§' : 'üè®';

            const label = document.createElement('span');
            label.className = 'message-label';
            label.textContent = sender === 'user' ? 'You' : 'Front Desk';

            if (sender === 'user') {
                headerDiv.appendChild(label);
                headerDiv.appendChild(avatar);
            } else {
                headerDiv.appendChild(avatar);
                headerDiv.appendChild(label);
            }

            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';
            
            // Format content
            let formattedContent = content
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');
            
            bubble.innerHTML = formattedContent;

            messageDiv.appendChild(headerDiv);
            messageDiv.appendChild(bubble);

            // Add quick option buttons if this is the greeting
            if (showOptions && sender === 'agent') {
                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'quick-options';
                
                const options = [
                    { num: '1', text: 'Check Rooms' },
                    { num: '2', text: 'Book Room' },
                    { num: '3', text: 'Cancel Booking' },
                    { num: '4', text: 'Amenities' },
                    { num: '5', text: 'Policies & FAQ' }
                ];

                options.forEach(opt => {
                    const btn = document.createElement('button');
                    btn.className = 'option-btn';
                    btn.textContent = `${opt.num}. ${opt.text}`;
                    btn.onclick = () => selectOption(opt.num);
                    optionsDiv.appendChild(btn);
                });

                bubble.appendChild(optionsDiv);
            }
            
            // Add contact details form if asking for contact details
            if (sender === 'agent' && content.includes('Please provide your contact details')) {
                const contactFormDiv = document.createElement('div');
                contactFormDiv.style.marginTop = '16px';
                
                const formHTML = `
                    <div class="booking-widget">
                        <h3>üìã Guest Information</h3>
                        <div class="widget-grid">
                            <div class="widget-field full-width">
                                <label for="guestName">Full Name *</label>
                                <input type="text" id="guestName" placeholder="John Smith" required>
                            </div>
                            <div class="widget-field full-width">
                                <label for="guestPhone">Phone Number *</label>
                                <input type="tel" id="guestPhone" placeholder="+1-555-0123" required>
                            </div>
                            <div class="widget-field full-width">
                                <label for="guestEmail">Email Address (Optional)</label>
                                <input type="email" id="guestEmail" placeholder="john@example.com">
                            </div>
                            <div class="widget-field full-width">
                                <label for="specialRequests">Special Requests (Optional)</label>
                                <textarea id="specialRequests" placeholder="Late check-in, accessible room, etc." style="padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; font-family: inherit; background: #f8fafc; min-height: 60px; resize: vertical;"></textarea>
                            </div>
                        </div>
                        
                        <h3 style="margin-top: 24px; padding-top: 24px; border-top: 2px solid #e2e8f0;">üí≥ Payment Information</h3>
                        <div class="widget-grid">
                            <div class="widget-field full-width">
                                <label for="cardNumber">Card Number *</label>
                                <input type="text" id="cardNumber" placeholder="1234 5678 9012 3456" maxlength="19" required oninput="formatCardNumber(this)">
                            </div>
                            <div class="widget-field">
                                <label for="cardExpiry">Expiry Date *</label>
                                <input type="text" id="cardExpiry" placeholder="MM/YY" maxlength="5" required oninput="formatExpiry(this)">
                            </div>
                            <div class="widget-field">
                                <label for="cardCVV">CVV *</label>
                                <input type="text" id="cardCVV" placeholder="123" maxlength="4" required oninput="this.value=this.value.replace(/[^0-9]/g,'')">
                            </div>
                        </div>
                        
                        <div style="background: #f0f9ff; border: 1px solid #0891b2; border-radius: 8px; padding: 12px; margin: 16px 0; font-size: 13px; color: #0e7490;">
                            üîí Your payment information is secure and encrypted
                        </div>
                        
                        <div class="widget-actions">
                            <button class="widget-btn secondary" onclick="skipPaymentInfo()">Skip Payment</button>
                            <button class="widget-btn primary" onclick="submitContactAndPayment()">Complete Booking</button>
                        </div>
                    </div>
                `;
                
                contactFormDiv.innerHTML = formHTML;
                bubble.appendChild(contactFormDiv);
            }
            
            // Add room selection buttons if this is a room listing
            if (sender === 'agent' && content.includes('Which room would you like?')) {
                const roomButtons = extractRoomButtons(content);
                if (roomButtons.length > 0) {
                    const roomOptionsDiv = document.createElement('div');
                    roomOptionsDiv.style.display = 'grid';
                    roomOptionsDiv.style.gridTemplateColumns = 'repeat(auto-fit, minmax(280px, 1fr))';
                    roomOptionsDiv.style.gap = '12px';
                    roomOptionsDiv.style.marginTop = '16px';
                    
                    roomButtons.forEach(room => {
                        const roomCard = document.createElement('div');
                        roomCard.style.border = '2px solid #e2e8f0';
                        roomCard.style.borderRadius = '12px';
                        roomCard.style.padding = '16px';
                        roomCard.style.background = '#f8fafc';
                        roomCard.style.transition = 'all 0.2s';
                        roomCard.onmouseover = () => {
                            roomCard.style.borderColor = '#0891b2';
                            roomCard.style.background = 'white';
                            roomCard.style.transform = 'translateY(-2px)';
                            roomCard.style.boxShadow = '0 4px 12px rgba(8, 145, 178, 0.15)';
                        };
                        roomCard.onmouseout = () => {
                            roomCard.style.borderColor = '#e2e8f0';
                            roomCard.style.background = '#f8fafc';
                            roomCard.style.transform = 'translateY(0)';
                            roomCard.style.boxShadow = 'none';
                        };
                        
                        roomCard.innerHTML = `
                            <div style="font-weight: 600; font-size: 16px; color: #1e293b; margin-bottom: 8px;">
                                üè® ${room.name}
                            </div>
                            <div style="font-size: 14px; color: #64748b; margin-bottom: 12px;">
                                <div>üí∞ $${room.pricePerNight}/night ‚Ä¢ ${room.capacity} guests</div>
                                ${room.roomNumber ? `<div style="font-size: 12px; margin-top: 4px;">Room #${room.roomNumber}</div>` : ''}
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button onclick="selectRoom('${room.type}')" style="flex: 1; padding: 10px; background: #0891b2; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
                                    Select Room
                                </button>
                                <button onclick="showRoomDetails(${JSON.stringify(room).replace(/"/g, '&quot;')})" style="padding: 10px 16px; background: #f1f5f9; color: #475569; border: 1px solid #cbd5e1; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
                                    Details
                                </button>
                            </div>
                        `;
                        
                        roomOptionsDiv.appendChild(roomCard);
                    });

                    bubble.appendChild(roomOptionsDiv);
                }
            }

            container.appendChild(messageDiv);

            // Scroll to bottom
            container.scrollTop = container.scrollHeight;
        }

        function selectOption(num) {
            // If selecting "Book Room" (option 2) or "Check Rooms" (option 1), show booking widget
            if (num === '2') {
                showBookingWidget('book');
                return;
            } else if (num === '1') {
                showBookingWidget('check');
                return;
            }
            
            document.getElementById('userInput').value = num;
            sendMessage();
        }
        
        function extractRoomButtons(content) {
            const rooms = [];
            const lines = content.split('\n');
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                // Match room names like "Queen Guest Room (Room #201)"
                const roomMatch = line.match(/\*\*(.+?)\*\*\s*(?:\(Room #(\d+)\)|at (.+))?/);
                if (roomMatch) {
                    const roomName = roomMatch[1].trim();
                    const roomNumber = roomMatch[2] || null;
                    
                    // Extract price, capacity, and amenities from next lines
                    let pricePerNight = null;
                    let totalPrice = null;
                    let capacity = null;
                    let amenities = [];
                    
                    for (let j = i + 1; j < Math.min(i + 10, lines.length); j++) {
                        const nextLine = lines[j];
                        
                        if (!capacity) {
                            const capacityMatch = nextLine.match(/Capacity:\s*(\d+)/);
                            if (capacityMatch) capacity = capacityMatch[1];
                        }
                        if (!pricePerNight) {
                            const priceMatch = nextLine.match(/\$(\d+(?:\.\d+)?)\/night/);
                            if (priceMatch) pricePerNight = priceMatch[1];
                        }
                        if (!totalPrice) {
                            const totalMatch = nextLine.match(/=\s*\*?\*?\$(\d+(?:\.\d+)?)\s*total/);
                            if (totalMatch) totalPrice = totalMatch[1];
                        }
                        if (nextLine.includes('Amenities:')) {
                            const amenitiesMatch = nextLine.match(/Amenities:\s*(.+)/);
                            if (amenitiesMatch) {
                                amenities = amenitiesMatch[1].split(',').map(a => a.trim());
                            }
                        }
                        
                        // Stop if we hit another room
                        if (nextLine.includes('**') && nextLine !== line) break;
                    }
                    
                    // Determine room type keyword for backend
                    let roomType = roomName; // Use full name as unique identifier
                    const nameLower = roomName.toLowerCase();
                    let searchKeyword = 'queen'; // default
                    if (nameLower.includes('king')) searchKeyword = 'king';
                    else if (nameLower.includes('suite')) searchKeyword = 'suite';
                    else if (nameLower.includes('executive')) searchKeyword = 'executive';
                    else if (nameLower.includes('accessible')) searchKeyword = 'accessible';
                    else if (nameLower.includes('standard')) searchKeyword = 'standard';
                    else if (nameLower.includes('deluxe')) searchKeyword = 'deluxe';
                    
                    rooms.push({
                        name: roomName,
                        type: searchKeyword,
                        fullType: roomType,
                        roomNumber: roomNumber,
                        pricePerNight: pricePerNight || '0',
                        totalPrice: totalPrice || pricePerNight || '0',
                        capacity: capacity || '2',
                        amenities: amenities
                    });
                }
            }
            
            // Remove duplicates by full name
            const uniqueRooms = [];
            const seenNames = new Set();
            for (const room of rooms) {
                if (!seenNames.has(room.fullType)) {
                    uniqueRooms.push(room);
                    seenNames.add(room.fullType);
                }
            }
            
            return uniqueRooms;
        }
        
        function selectRoom(roomType) {
            const input = document.getElementById('userInput');
            input.value = roomType;
            sendMessage();
        }
        
        function formatCardNumber(input) {
            let value = input.value.replace(/\s/g, '').replace(/[^0-9]/g, '');
            let formattedValue = value.match(/.{1,4}/g)?.join(' ') || value;
            input.value = formattedValue;
        }
        
        function formatExpiry(input) {
            let value = input.value.replace(/\D/g, '');
            if (value.length >= 2) {
                value = value.slice(0, 2) + '/' + value.slice(2, 4);
            }
            input.value = value;
        }
        
        function submitContactAndPayment() {
            const guestName = document.getElementById('guestName')?.value?.trim();
            const phone = document.getElementById('guestPhone')?.value?.trim();
            const email = document.getElementById('guestEmail')?.value?.trim() || '';
            const requests = document.getElementById('specialRequests')?.value?.trim() || '';
            const cardNumber = document.getElementById('cardNumber')?.value;
            const cardExpiry = document.getElementById('cardExpiry')?.value;
            const cardCVV = document.getElementById('cardCVV')?.value;
            
            // Validate required fields
            if (!guestName) {
                alert('Please enter your full name');
                return;
            }
            
            if (!phone) {
                alert('Please enter your phone number');
                return;
            }
            
            if (!cardNumber || !cardExpiry || !cardCVV) {
                alert('Please fill in all required payment fields');
                return;
            }
            
            // Validate card number (basic check - should be 13-19 digits)
            const cardDigits = cardNumber.replace(/\s/g, '');
            if (cardDigits.length < 13 || cardDigits.length > 19) {
                alert('Please enter a valid card number');
                return;
            }
            
            // Validate expiry
            if (!cardExpiry.match(/^\d{2}\/\d{2}$/)) {
                alert('Please enter expiry in MM/YY format');
                return;
            }
            
            // Validate CVV
            if (cardCVV.length < 3 || cardCVV.length > 4) {
                alert('Please enter a valid CVV');
                return;
            }
            
            // Mask card number for security (show only last 4 digits)
            const maskedCard = '****' + cardDigits.slice(-4);
            
            // Create message with all details (name, phone, email, requests, payment)
            const message = `${guestName}, ${phone}${email ? ', ' + email : ''}${requests ? ', ' + requests : ''}, Payment: ${guestName} ${maskedCard}`;
            
            // Send to backend
            const input = document.getElementById('userInput');
            input.value = message;
            sendMessage();
        }
        
        function skipPaymentInfo() {
            const guestName = document.getElementById('guestName')?.value?.trim();
            const phone = document.getElementById('guestPhone')?.value?.trim();
            const email = document.getElementById('guestEmail')?.value?.trim() || '';
            const requests = document.getElementById('specialRequests')?.value?.trim() || '';
            
            // Validate required fields
            if (!guestName) {
                alert('Full name is required. Please enter your full name.');
                return;
            }
            
            if (!phone) {
                alert('Phone number is required. Please enter your phone number.');
                return;
            }
            
            // Send contact details without payment
            const message = `${guestName}, ${phone}${email ? ', ' + email : ''}${requests ? ', ' + requests : ''}`;
            
            const input = document.getElementById('userInput');
            input.value = message;
            sendMessage();
        }
        
        function showRoomDetails(room) {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'rgba(0, 0, 0, 0.5)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '10000';
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            };
            
            // Create modal
            const modal = document.createElement('div');
            modal.style.background = 'white';
            modal.style.borderRadius = '16px';
            modal.style.padding = '32px';
            modal.style.maxWidth = '500px';
            modal.style.width = '90%';
            modal.style.maxHeight = '80vh';
            modal.style.overflow = 'auto';
            modal.style.boxShadow = '0 20px 60px rgba(0,0,0,0.3)';
            
            const amenitiesList = room.amenities && room.amenities.length > 0 
                ? room.amenities.map(a => `<li style="margin: 8px 0;">‚úì ${a}</li>`).join('')
                : '<li style="margin: 8px 0;">Standard amenities included</li>';
            
            modal.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                    <h2 style="margin: 0; color: #0891b2; font-size: 24px;">üè® ${room.name}</h2>
                    <button onclick="this.closest('.modal-overlay').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #64748b; padding: 0; width: 32px; height: 32px;">√ó</button>
                </div>
                
                <div style="background: #f8fafc; border-radius: 12px; padding: 20px; margin-bottom: 24px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                        <div>
                            <div style="font-size: 13px; color: #64748b; margin-bottom: 4px;">Price per Night</div>
                            <div style="font-size: 24px; font-weight: 600; color: #0891b2;">$${room.pricePerNight}</div>
                        </div>
                        <div>
                            <div style="font-size: 13px; color: #64748b; margin-bottom: 4px;">Total Price</div>
                            <div style="font-size: 24px; font-weight: 600; color: #0891b2;">$${room.totalPrice}</div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="font-size: 14px; color: #64748b; margin-bottom: 8px;">
                        <strong>Capacity:</strong> ${room.capacity} guests
                    </div>
                    ${room.roomNumber ? `<div style="font-size: 14px; color: #64748b; margin-bottom: 8px;"><strong>Room Number:</strong> #${room.roomNumber}</div>` : ''}
                </div>
                
                <div style="margin-bottom: 24px;">
                    <h3 style="font-size: 16px; color: #1e293b; margin-bottom: 12px;">Room Amenities</h3>
                    <ul style="list-style: none; padding: 0; margin: 0;">
                        ${amenitiesList}
                    </ul>
                </div>
                
                <div style="display: flex; gap: 12px;">
                    <button onclick="selectRoom('${room.type}'); this.closest('.modal-overlay').remove();" style="flex: 1; padding: 14px; background: #0891b2; color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; font-size: 16px;">
                        Select This Room
                    </button>
                    <button onclick="this.closest('.modal-overlay').remove()" style="padding: 14px 24px; background: #f1f5f9; color: #475569; border: 1px solid #cbd5e1; border-radius: 10px; font-weight: 600; cursor: pointer; font-size: 16px;">
                        Close
                    </button>
                </div>
            `;
            
            overlay.className = 'modal-overlay';
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }

        function showBookingWidget(mode = 'book') {
            const container = document.getElementById('chatContainer');
            
            // Remove any existing booking widget
            const existingWidget = document.querySelector('.booking-widget-message');
            if (existingWidget) {
                existingWidget.remove();
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message agent-message booking-widget-message';
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'message-header';
            headerDiv.innerHTML = '<span class="sender-icon">üè®</span><span class="sender-name">Front Desk</span>';
            
            const bubble = document.createElement('div');
            bubble.className = 'message-bubble agent';
            
            // Set tomorrow as minimum date
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            const minDate = tomorrow.toISOString().split('T')[0];
            
            const dayAfter = new Date(tomorrow);
            dayAfter.setDate(dayAfter.getDate() + 1);
            const defaultCheckout = dayAfter.toISOString().split('T')[0];
            
            const widgetHTML = `
                <div class="booking-widget">
                    <h3>üìÖ ${mode === 'book' ? 'Book Your Stay' : 'Check Availability'}</h3>
                    <div class="widget-grid">
                        <div class="widget-field">
                            <label for="checkInDate">Check-in Date</label>
                            <input type="date" id="checkInDate" min="${minDate}" value="${minDate}" onchange="updateCheckoutMin()">
                        </div>
                        <div class="widget-field">
                            <label for="checkOutDate">Check-out Date</label>
                            <input type="date" id="checkOutDate" min="${defaultCheckout}" value="${defaultCheckout}" onchange="calculateNights()">
                        </div>
                        <div class="widget-field">
                            <label for="numGuests">Number of Guests</label>
                            <select id="numGuests" onchange="calculateNights()">
                                ${[1,2,3,4,5,6,7,8].map(n => `<option value="${n}" ${n === 2 ? 'selected' : ''}>${n} Guest${n > 1 ? 's' : ''}</option>`).join('')}
                            </select>
                        </div>
                        <div class="widget-field">
                            <label for="numNights">Nights</label>
                            <input type="number" id="numNights" value="1" min="1" max="30" readonly style="background: #e2e8f0;">
                        </div>
                    </div>
                    <div class="widget-actions">
                        <button class="widget-btn secondary" onclick="hideBookingWidget()">Cancel</button>
                        <button class="widget-btn primary" onclick="submitBookingWidget('${mode}')">
                            ${mode === 'book' ? 'Find Rooms' : 'Check Availability'}
                        </button>
                    </div>
                </div>
            `;
            
            bubble.innerHTML = widgetHTML;
            messageDiv.appendChild(headerDiv);
            messageDiv.appendChild(bubble);
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            
            // Calculate initial nights
            calculateNights();
        }

        function updateCheckoutMin() {
            const checkIn = document.getElementById('checkInDate');
            const checkOut = document.getElementById('checkOutDate');
            
            if (checkIn.value) {
                const minCheckout = new Date(checkIn.value);
                minCheckout.setDate(minCheckout.getDate() + 1);
                checkOut.min = minCheckout.toISOString().split('T')[0];
                
                // If checkout is before checkin, update it
                if (checkOut.value && new Date(checkOut.value) <= new Date(checkIn.value)) {
                    checkOut.value = checkOut.min;
                }
                
                calculateNights();
            }
        }

        function calculateNights() {
            const checkIn = document.getElementById('checkInDate');
            const checkOut = document.getElementById('checkOutDate');
            const nightsInput = document.getElementById('numNights');
            
            if (checkIn && checkOut && checkIn.value && checkOut.value) {
                const checkInDate = new Date(checkIn.value);
                const checkOutDate = new Date(checkOut.value);
                const diffTime = checkOutDate - checkInDate;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                
                if (nightsInput) {
                    nightsInput.value = Math.max(1, diffDays);
                }
            }
        }

        function hideBookingWidget() {
            const widget = document.querySelector('.booking-widget-message');
            if (widget) {
                widget.remove();
            }
        }

        function submitBookingWidget(mode) {
            const checkIn = document.getElementById('checkInDate').value;
            const checkOut = document.getElementById('checkOutDate').value;
            const guests = document.getElementById('numGuests').value;
            const nights = document.getElementById('numNights').value;
            
            if (!checkIn || !checkOut) {
                alert('Please select both check-in and check-out dates');
                return;
            }
            
            // Format dates nicely
            const checkInObj = new Date(checkIn);
            const checkOutObj = new Date(checkOut);
            const checkInFormatted = checkInObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            const checkOutFormatted = checkOutObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            
            // Hide the widget
            hideBookingWidget();
            
            // Create ONE message to send to backend
            const message = `${guests} guests, ${checkInFormatted} to ${checkOutFormatted}`;
            
            // Set the message in the input field and send it
            // sendMessage() will handle adding the user message to the chat
            const input = document.getElementById('userInput');
            input.value = message;
            sendMessage();
        }

        function showTypingIndicator() {
            const container = document.getElementById('chatContainer');
            const indicator = document.createElement('div');
            indicator.className = 'typing-indicator active';
            indicator.id = 'typingIndicator';
            indicator.innerHTML = '<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>';
            container.appendChild(indicator);
            container.scrollTop = container.scrollHeight;
        }

        function hideTypingIndicator() {
            const indicator = document.getElementById('typingIndicator');
            if (indicator) {
                indicator.remove();
            }
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        function toggleVoiceMode() {
            if (!recognition) {
                alert('Voice recognition is not supported in this browser. Please try Chrome or Edge.');
                return;
            }

            isVoiceMode = !isVoiceMode;
            const voiceBtn = document.getElementById('voiceBtn');

            if (isVoiceMode) {
                voiceBtn.classList.add('voice-active');
                voiceBtn.textContent = 'üî¥ Stop Voice';
                recognition.start();
                updateStatus('Voice mode active - listening...');
            } else {
                stopVoiceMode();
            }
        }

        function stopVoiceMode() {
            isVoiceMode = false;
            const voiceBtn = document.getElementById('voiceBtn');
            voiceBtn.classList.remove('voice-active');
            voiceBtn.textContent = 'üé§ Voice Mode';
            if (recognition) {
                recognition.stop();
            }
            updateStatus('Connected ‚Ä¢ Ready to assist');
        }

        function speakText(text) {
            synthesis.cancel();
            const cleanText = text
                .replace(/\*\*(.*?)\*\*/g, '$1')
                .replace(/[#‚Ä¢]/g, '');

            const utterance = new SpeechSynthesisUtterance(cleanText);
            utterance.rate = 0.9;
            utterance.pitch = 1;
            utterance.volume = 1;
            synthesis.speak(utterance);
        }

        function clearChat() {
            if (confirm('Clear all messages?')) {
                document.getElementById('chatContainer').innerHTML = '';
                // Generate new session ID on clear
                sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                loadGreeting();
                updateStatus('Connected ‚Ä¢ Ready to assist');
            }
        }
        
        // ==================== VAPI VOICE CALL FUNCTIONS ====================
        
        function setupVapiListeners() {
            if (!vapiInstance) return;
            
            vapiInstance.on('call-start', () => {
                console.log('Call started');
                isCallActive = true;
                const callBtn = document.getElementById('callBtn');
                callBtn.classList.add('call-active');
                callBtn.textContent = 'üìû End Call';
                updateStatus('üéôÔ∏è AI Assistant Speaking - Microphone Active');
                addMessage('agent', 'üìû **Voice call connected!**\n\nü§ñ You\'re now speaking with our **AI assistant**. I can help with bookings, room info, and common questions.\n\nüë§ If needed, I\'ll transfer you to a **human customer support agent** at any time.');
            });
            
            vapiInstance.on('call-end', () => {
                console.log('Call ended');
                isCallActive = false;
                const callBtn = document.getElementById('callBtn');
                callBtn.classList.remove('call-active');
                callBtn.textContent = 'üìû Talk to AI';
                updateStatus('Connected ‚Ä¢ Ready to assist');
                addMessage('agent', 'üìû **Voice call ended.** Feel free to continue via text or start another call anytime!');
            });
            
            vapiInstance.on('speech-start', () => {
                console.log('User started speaking');
                updateStatus('üé§ Listening...');
            });
            
            vapiInstance.on('speech-end', () => {
                console.log('User stopped speaking');
                updateStatus('üéôÔ∏è AI Voice Call Active');
            });
            
            vapiInstance.on('message', (message) => {
                console.log('VAPI message:', message);
                
                // Show transcripts in chat
                if (message.type === 'transcript' && message.transcriptType === 'final') {
                    if (message.role === 'user') {
                        addMessage('user', 'üé§ ' + message.transcript);
                    } else if (message.role === 'assistant') {
                        addMessage('agent', 'ü§ñ ' + message.transcript);
                    }
                }
                
                // Handle function calls and detect transfers
                if (message.type === 'function-call') {
                    const functionName = message.functionCall?.name;
                    
                    if (functionName === 'transfer_to_agent') {
                        // Show transfer message
                        updateStatus('üìû Transferring to human agent...');
                        addMessage('agent', 'üë§ **Transferring to Customer Support**\n\nA human agent will be with you shortly. In a production environment, this would connect you to our live support team.');
                        
                        // Simulate transfer delay then show human agent message
                        setTimeout(() => {
                            updateStatus('üë§ Connected to Human Agent');
                            const callBtn = document.getElementById('callBtn');
                            callBtn.classList.remove('call-active');
                            callBtn.classList.add('call-btn');
                            callBtn.style.background = '#f59e0b';
                            callBtn.textContent = 'üë§ Human Agent';
                            addMessage('agent', 'üëã **Hello! I\'m a human customer support agent.**\n\nI see you were transferred from our AI assistant. How can I personally help you today?');
                        }, 2000);
                    }
                    
                    handleVapiFunctionCall(message);
                }
            });
            
            vapiInstance.on('error', (error) => {
                console.error('VAPI error:', error);
                updateStatus('‚ùå Call error - Please try again');
                addMessage('agent', '‚ùå **Call error:** ' + (error.message || 'Unable to connect. Please try again or use text chat.'));
            });
        }
        
        async function startVoiceCall() {
            // Try to initialize VAPI if not already done
            if (!vapiInstance) {
                console.log('VAPI not initialized, attempting now...');
                const initialized = await initializeVapi();
                
                if (!initialized || !vapiInstance) {
                    // VAPI not available - use demo mode with Web Speech API
                    console.log('‚ö†Ô∏è VAPI unavailable, using demo voice mode');
                    startDemoVoiceCall();
                    return;
                }
            }
            
            if (isCallActive) {
                // End the call
                vapiInstance.stop();
                return;
            }
            
            try {
                // Get assistant configuration from server
                const response = await fetch('/api/vapi/web-call-config');
                if (!response.ok) {
                    throw new Error('Failed to get call configuration');
                }
                
                const config = await response.json();
                
                if (!config.assistant) {
                    throw new Error('Invalid assistant configuration');
                }
                
                // Start the call
                updateStatus('üìû Connecting voice call...');
                await vapiInstance.start(config.assistant);
                
            } catch (error) {
                console.error('Error starting call:', error);
                updateStatus('Connected ‚Ä¢ Ready to assist');
                addMessage('agent', '‚ùå **Unable to start voice call**\n\n' + 
                    'Error: ' + (error.message || 'Unknown error') + '\n\n' +
                    'Please try:\n‚Ä¢ Refreshing the page\n‚Ä¢ Using text chat instead\n‚Ä¢ Checking VAPI configuration');
            }
        }
        
        async function handleVapiFunctionCall(message) {
            // Function calls from VAPI assistant are handled by the server webhook
            // Just log them here for debugging
            console.log('Function call:', message.functionCall);
        }
        
        // ==================== DEMO VOICE MODE (Fallback) ====================
        
        function startDemoVoiceCall() {
            if (isCallActive) {
                // End demo call
                endCallScreen();
                return;
            }
            
            // Check if browser supports speech recognition
            if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
                alert('Voice mode requires Chrome, Edge, or Safari. Please use text chat.');
                return;
            }
            
            // Open calling screen
            openCallScreen();
        }
        
        async function openCallScreen() {
            // Request microphone permission first
            try {
                console.log('üé§ Requesting microphone permission...');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                console.log('‚úÖ Microphone access granted');
                
                // Stop the stream immediately (we just needed permission)
                stream.getTracks().forEach(track => track.stop());
            } catch (error) {
                console.error('‚ùå Microphone permission denied:', error);
                alert('Microphone access is required for voice calling. Please allow microphone access and try again.');
                return;
            }
            
            isCallActive = true;
            
            // Create calling overlay
            const overlay = document.createElement('div');
            overlay.className = 'calling-overlay';
            overlay.id = 'callingOverlay';
            
            overlay.innerHTML = `
                <div class="calling-screen">
                    <div class="calling-avatar speaking" id="callAvatar">ü§ñ</div>
                    <div class="calling-name">AI Assistant (Sarah)</div>
                    <div class="calling-status active" id="callStatus">Connecting...</div>
                    
                    <div class="calling-transcript" id="callTranscript">
                        <div style="text-align: center; color: #94a3b8; font-size: 13px;">
                            Call transcript will appear here...
                        </div>
                    </div>
                    
                    <div style="background: #dcfce7; border: 1px solid #10b981; border-radius: 8px; padding: 12px; margin: 20px 0; font-size: 13px; color: #14532d;">
                        <div id="micIndicator" style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                            <span style="font-size: 20px;">üé§</span>
                            <span>Microphone ready - waiting for your turn to speak</span>
                        </div>
                        <div style="text-align: center; font-size: 11px; margin-top: 8px; color: #059669;">
                            If auto-listening doesn't work, use the button below
                        </div>
                    </div>
                    
                    <button id="pushToTalk" onclick="manualPushToTalk()" style="width: 100%; padding: 16px; background: #0891b2; color: white; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 20px; box-shadow: 0 4px 12px rgba(8, 145, 178, 0.3);">
                        üé§ Click & Speak
                    </button>
                    
                    <div class="calling-controls">
                        <button class="call-btn-large mute" id="muteBtn" onclick="toggleMute()" title="Mute">
                            üé§
                        </button>
                        <button class="call-btn-large end-call" onclick="endCallScreen()" title="End Call">
                            üìû
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Update header button
            const callBtn = document.getElementById('callBtn');
            callBtn.classList.add('call-active');
            callBtn.textContent = 'üìû In Call';
            
            // Start the conversation - AI speaks first
            setTimeout(() => {
                aiSpeakFirst();
            }, 800);
        }
        
        function aiSpeakFirst() {
            const greeting = "Hello! Thank you for calling Hilton Charlotte Airport. I'm Sarah, your AI assistant. How can I help you today?";
            
            updateCallStatus('ü§ñ AI Speaking...');
            addToCallTranscript('ai', greeting);
            
            // Speak the greeting
            if (synthesis) {
                // Make sure synthesis is ready
                if (synthesis.getVoices().length === 0) {
                    synthesis.addEventListener('voiceschanged', () => {
                        speakGreeting(greeting);
                    }, { once: true });
                } else {
                    speakGreeting(greeting);
                }
            } else {
                // No synthesis, just start listening
                setTimeout(() => listenForUser(), 1000);
            }
        }
        
        function speakGreeting(text) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.1;
            utterance.pitch = 1.1;
            
            const voices = synthesis.getVoices();
            const femaleVoice = voices.find(v => v.name.toLowerCase().includes('female') || v.name.toLowerCase().includes('samantha'));
            if (femaleVoice) utterance.voice = femaleVoice;
            
            utterance.onstart = () => {
                console.log('üîä AI started speaking');
                setAvatarSpeaking(true);
            };
            
            utterance.onend = () => {
                console.log('‚úÖ AI finished speaking, now listening for user');
                setAvatarSpeaking(false);
                // After AI finishes speaking, start listening for user
                if (isCallActive) {
                    setTimeout(() => {
                        listenForUser();
                    }, 800);
                }
            };
            
            utterance.onerror = (error) => {
                console.error('Speech synthesis error:', error);
                setAvatarSpeaking(false);
                setTimeout(() => listenForUser(), 1000);
            };
            
            synthesis.speak(utterance);
        }
        
        async function listenForUser() {
            if (!isCallActive) {
                console.log('‚ö†Ô∏è Call not active, stopping listen');
                return;
            }
            
            console.log('üëÇ Starting to listen for user...');
            updateCallStatus('üé§ Listening... (You can speak now)');
            
            // Cancel any ongoing speech synthesis
            if (synthesis && synthesis.speaking) {
                console.log('üõë Canceling synthesis before starting recognition');
                synthesis.cancel();
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            if (!recognition) {
                console.log('üéôÔ∏è Initializing speech recognition...');
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = true;  // Changed to continuous for better reliability
                recognition.interimResults = true;  // Show interim results
                recognition.lang = 'en-US';
                recognition.maxAlternatives = 1;
                
                let finalTranscript = '';
                let interimTranscript = '';
                
                recognition.onstart = () => {
                    console.log('‚úÖ‚úÖ‚úÖ Recognition STARTED - MIC IS ACTIVE - SPEAK NOW! ‚úÖ‚úÖ‚úÖ');
                    
                    // Update microphone indicator
                    const micIndicator = document.getElementById('micIndicator');
                    if (micIndicator) {
                        micIndicator.innerHTML = `
                            <span style="font-size: 20px; animation: pulse 1s infinite;">üî¥</span>
                            <span style="font-weight: 600;">LISTENING NOW - Speak clearly into your microphone</span>
                        `;
                        micIndicator.parentElement.style.background = '#fee2e2';
                        micIndicator.parentElement.style.borderColor = '#dc2626';
                    }
                };
                
                recognition.onsoundstart = () => {
                    console.log('üîäüîäüîä SOUND DETECTED! Microphone is hearing audio! üîäüîäüîä');
                };
                
                recognition.onspeechstart = () => {
                    console.log('üó£Ô∏èüó£Ô∏èüó£Ô∏è SPEECH DETECTED! User is speaking! üó£Ô∏èüó£Ô∏èüó£Ô∏è');
                };
                
                recognition.onspeechend = () => {
                    console.log('ü§ê Speech ended, processing what you said...');
                };
                
                recognition.onsoundend = () => {
                    console.log('üîá Sound ended');
                };
                
                recognition.onaudiostart = () => {
                    console.log('üéµ Audio input started');
                };
                
                recognition.onaudioend = () => {
                    console.log('üéµ Audio input ended');
                };
                
                recognition.onresult = async (event) => {
                    console.log('üì• AUTO-LISTEN: Got recognition result event!');
                    interimTranscript = '';
                    
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const result = event.results[i];
                        const transcript = result[0].transcript;
                        const confidence = (result[0].confidence * 100).toFixed(1);
                        
                        if (result.isFinal) {
                            finalTranscript += transcript;
                            console.log('üìùüìùüìù AUTO-LISTEN FINAL TRANSCRIPT:', transcript, 'confidence:', confidence + '%');
                            console.log('‚úÖ Your speech was captured!');
                            
                            // Stop recognition temporarily while processing
                            recognition.stop();
                            
                            // Reset microphone indicator
                            const micIndicator = document.getElementById('micIndicator');
                            if (micIndicator) {
                                micIndicator.innerHTML = `
                                    <span style="font-size: 20px;">‚úÖ</span>
                                    <span>Got it! Processing your request...</span>
                                `;
                                micIndicator.parentElement.style.background = '#dcfce7';
                                micIndicator.parentElement.style.borderColor = '#10b981';
                            }
                            
                            updateCallStatus('ü§ñ Processing your request...');
                            addToCallTranscript('user', finalTranscript);
                            
                            // Send to backend and get AI response
                            await getAIResponse(finalTranscript);
                            
                            // Reset for next turn
                            finalTranscript = '';
                            
                        } else {
                            interimTranscript += transcript;
                            console.log('üîÑ AUTO-LISTEN Interim transcript:', interimTranscript, 'confidence:', confidence + '%');
                        }
                    }
                };
                
                recognition.onerror = (event) => {
                    console.error('‚ùå Speech recognition error:', event.error);
                    
                    if (event.error === 'no-speech') {
                        console.log('‚ö†Ô∏è No speech detected, listening again...');
                        updateCallStatus('‚ö†Ô∏è No speech detected. Try speaking again...');
                        setTimeout(() => {
                            if (isCallActive) {
                                try {
                                    recognition.start();
                                } catch (e) {
                                    console.error('Restart error:', e);
                                }
                            }
                        }, 1500);
                    } else if (event.error === 'not-allowed') {
                        updateCallStatus('‚ùå Microphone access denied');
                        alert('Please allow microphone access to use voice calling.');
                        endCallScreen();
                    } else {
                        console.log('‚ö†Ô∏è Recognition error, restarting...');
                        setTimeout(() => {
                            if (isCallActive) {
                                try {
                                    recognition.start();
                                } catch (e) {}
                            }
                        }, 1000);
                    }
                };
                
                recognition.onend = () => {
                    console.log('üî¥ Recognition ended');
                    console.log('üìä Call still active?', isCallActive);
                    console.log('üìä Synthesis speaking?', synthesis.speaking);
                    
                    // Reset mic indicator
                    const micIndicator = document.getElementById('micIndicator');
                    if (micIndicator && isCallActive) {
                        micIndicator.innerHTML = `
                            <span style="font-size: 20px;">üé§</span>
                            <span>Microphone ready - waiting for next turn</span>
                        `;
                        micIndicator.parentElement.style.background = '#dcfce7';
                        micIndicator.parentElement.style.borderColor = '#10b981';
                    }
                };
            }
            
            try {
                console.log('üöÄ Starting speech recognition...');
                console.log('üìä Recognition state before start:', {
                    continuous: recognition.continuous,
                    lang: recognition.lang,
                    interimResults: recognition.interimResults
                });
                
                // Make sure synthesis is done
                if (synthesis.speaking) {
                    console.log('‚ö†Ô∏è Synthesis still speaking, waiting...');
                    synthesis.cancel();
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                recognition.start();
                console.log('‚úÖ recognition.start() called successfully');
                
                // Check faster - if onstart doesn't fire within 1 second, show manual button
                let recognitionStarted = false;
                
                recognition.addEventListener('start', () => {
                    recognitionStarted = true;
                    console.log('‚úÖ onstart event fired - auto-listen working!');
                }, { once: true });
                
                setTimeout(() => {
                    console.log('üîç Checking if recognition actually started...');
                    
                    if (!recognitionStarted) {
                        console.log('‚ùå‚ùå‚ùå AUTO-LISTENING FAILED! ‚ùå‚ùå‚ùå');
                        console.log('üìç SOLUTION: CLICK THE "üé§ Click & Speak" BUTTON BELOW!');
                        console.log('üí° Auto-start doesn\'t work on Safari/macOS - use manual button');
                        
                        // Stop the broken recognition
                        try {
                            recognition.stop();
                            recognition.abort();
                        } catch (e) {}
                        
                        const pushBtn = document.getElementById('pushToTalk');
                        if (pushBtn) {
                            pushBtn.style.background = '#10b981';
                            pushBtn.style.fontSize = '20px';
                            pushBtn.style.fontWeight = '700';
                            pushBtn.style.animation = 'pulse 2s infinite';
                            pushBtn.style.padding = '20px';
                            pushBtn.textContent = 'üëÜ CLICK ME TO SPEAK üëÜ';
                            
                            const micIndicator = document.getElementById('micIndicator');
                            if (micIndicator) {
                                micIndicator.innerHTML = `
                                    <span style="font-size: 24px;">üëá</span>
                                    <span style="font-weight: 700; font-size: 15px;">Auto-listen failed - CLICK BUTTON BELOW to speak</span>
                                `;
                                micIndicator.parentElement.style.background = '#fef9c3';
                                micIndicator.parentElement.style.borderColor = '#f59e0b';
                            }
                        }
                    }
                }, 1000);  // Faster check - 1 second instead of 2
                
            } catch (error) {
                console.error('‚ùå‚ùå‚ùå Recognition start FAILED:', error);
                console.error('Error details:', {
                    name: error.name,
                    message: error.message,
                    code: error.code
                });
                
                if (error.message && error.message.includes('already started')) {
                    console.log('Recognition already running, stopping and restarting...');
                    recognition.stop();
                    setTimeout(() => {
                        try {
                            if (isCallActive) recognition.start();
                        } catch (e) {
                            console.error('Restart failed:', e);
                        }
                    }, 500);
                } else {
                    updateCallStatus('‚ùå Microphone error - Click to try again');
                    const micIndicator = document.getElementById('micIndicator');
                    if (micIndicator) {
                        micIndicator.innerHTML = `
                            <span style="font-size: 20px;">‚ùå</span>
                            <span style="font-weight: 600; cursor: pointer;" onclick="listenForUser()">
                                Microphone failed - CLICK HERE to retry
                            </span>
                        `;
                        micIndicator.parentElement.style.background = '#fef2f2';
                        micIndicator.parentElement.style.borderColor = '#dc2626';
                    }
                }
            }
        }
        
        async function getAIResponse(userMessage) {
            console.log('üì§ Sending message to AI:', userMessage);
            
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: userMessage, session_id: sessionId })
                });
                
                const data = await response.json();
                console.log('üì• Got AI response:', data);
                
                if (data.success) {
                    let aiResponse = data.message;
                    
                    // Check if should transfer to human
                    const shouldTransfer = 
                        userMessage.toLowerCase().includes('speak to a person') ||
                        userMessage.toLowerCase().includes('human agent') ||
                        userMessage.toLowerCase().includes('real person') ||
                        userMessage.toLowerCase().includes('talk to someone');
                    
                    if (shouldTransfer) {
                        aiResponse = "I understand. Let me connect you with one of our human customer support specialists right away.";
                    }
                    
                    // AI speaks the response
                    updateCallStatus('ü§ñ AI Speaking...');
                    addToCallTranscript('ai', aiResponse);
                    
                    // Clean response for speech (remove markdown, special chars, bullets)
                    const cleanResponse = aiResponse
                        .replace(/\*\*/g, '')
                        .replace(/[#‚Ä¢‚úì‚ú®]/g, '')
                        .replace(/‚îÅ+/g, '')
                        .replace(/\n+/g, '. ')
                        .replace(/\. \./g, '.')
                        .substring(0, 500); // Limit length for speech
                    
                    console.log('üîä AI will say:', cleanResponse);
                    
                    if (synthesis && cleanResponse.trim()) {
                        setAvatarSpeaking(true);
                        
                        const utterance = new SpeechSynthesisUtterance(cleanResponse);
                        utterance.rate = 1.1;
                        utterance.pitch = 1.1;
                        
                        const voices = synthesis.getVoices();
                        const femaleVoice = voices.find(v => v.name.toLowerCase().includes('female') || v.name.toLowerCase().includes('samantha'));
                        if (femaleVoice) utterance.voice = femaleVoice;
                        
                        utterance.onstart = () => {
                            console.log('üîä AI speaking...');
                        };
                        
                        utterance.onend = () => {
                            console.log('‚úÖ AI finished speaking');
                            setAvatarSpeaking(false);
                            
                            if (shouldTransfer) {
                                console.log('üîÑ Initiating transfer...');
                                transferToHumanAgent();
                            } else if (isCallActive) {
                                // Continue listening
                                console.log('üëÇ Ready to listen again');
                                setTimeout(() => listenForUser(), 800);
                            }
                        };
                        
                        utterance.onerror = (error) => {
                            console.error('Speech synthesis error:', error);
                            setAvatarSpeaking(false);
                            if (isCallActive) {
                                setTimeout(() => listenForUser(), 1000);
                            }
                        };
                        
                        synthesis.speak(utterance);
                    } else {
                        console.log('‚ö†Ô∏è No synthesis or empty response');
                        setAvatarSpeaking(false);
                        if (shouldTransfer) {
                            transferToHumanAgent();
                        } else {
                            setTimeout(() => listenForUser(), 1000);
                        }
                    }
                } else {
                    console.error('‚ùå Backend error:', data);
                    updateCallStatus('‚ùå Error occurred');
                    setTimeout(() => listenForUser(), 2000);
                }
            } catch (error) {
                console.error('‚ùå Request error:', error);
                updateCallStatus('‚ùå Connection error');
                addToCallTranscript('system', 'Error: ' + error.message);
                setTimeout(() => listenForUser(), 2000);
            }
        }
        
        function transferToHumanAgent() {
            updateCallStatus('üìû Transferring to human agent...');
            
            // Change avatar to human
            setTimeout(() => {
                const avatar = document.getElementById('callAvatar');
                const name = document.querySelector('.calling-name');
                
                if (avatar) avatar.textContent = 'üë§';
                if (name) name.textContent = 'Human Agent (Michael)';
                updateCallStatus('üë§ Connected to Customer Support');
                
                addToCallTranscript('human', "Hello! I'm Michael from customer support. I can see your conversation with our AI assistant. How can I personally help you today?");
                
                // Speak transfer message
                if (synthesis) {
                    const utterance = new SpeechSynthesisUtterance("Hello! I'm Michael from customer support. I've reviewed your conversation with our AI assistant. How can I personally help you today?");
                    utterance.rate = 1;
                    utterance.pitch = 0.9;
                    utterance.onend = () => {
                        if (isCallActive) {
                            setTimeout(() => listenForUser(), 500);
                        }
                    };
                    synthesis.speak(utterance);
                }
            }, 2000);
        }
        
        function addToCallTranscript(role, text) {
            const transcript = document.getElementById('callTranscript');
            if (!transcript) return;
            
            // Clear placeholder if exists
            if (transcript.innerHTML.includes('Call transcript will appear')) {
                transcript.innerHTML = '';
            }
            
            const line = document.createElement('div');
            line.className = `transcript-line ${role}`;
            
            const icon = role === 'user' ? 'üé§ You' : role === 'ai' ? 'ü§ñ AI' : role === 'human' ? 'üë§ Agent' : '‚ö†Ô∏è System';
            line.innerHTML = `<strong>${icon}:</strong> ${text.substring(0, 150)}${text.length > 150 ? '...' : ''}`;
            
            transcript.appendChild(line);
            transcript.scrollTop = transcript.scrollHeight;
        }
        
        function updateCallStatus(status) {
            const statusEl = document.getElementById('callStatus');
            if (statusEl) {
                statusEl.textContent = status;
            }
        }
        
        function setAvatarSpeaking(speaking) {
            const avatar = document.getElementById('callAvatar');
            if (avatar) {
                if (speaking) {
                    avatar.classList.add('speaking');
                } else {
                    avatar.classList.remove('speaking');
                }
            }
        }
        
        function manualPushToTalk() {
            console.log('üîò Manual Push-to-Talk button clicked');
            
            const pushBtn = document.getElementById('pushToTalk');
            if (!pushBtn) return;
            
            // Force stop and recreate recognition for reliability
            if (recognition) {
                console.log('üõë Stopping existing recognition...');
                try {
                    recognition.stop();
                    recognition.abort();
                } catch (e) {
                    console.log('Stop error (ok):', e);
                }
                recognition = null;
            }
            
            console.log('üéôÔ∏è Creating FRESH speech recognition instance...');
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            
            let finalTranscript = '';
            let lastInterim = '';
            
            recognition.onstart = () => {
                console.log('‚úÖ‚úÖ‚úÖ MANUAL Recognition STARTED! MIC IS ACTIVE! ‚úÖ‚úÖ‚úÖ');
                pushBtn.style.background = '#dc2626';
                pushBtn.textContent = 'üî¥ Listening... (speak now!)';
                updateCallStatus('üé§ Recording your message...');
                
                const micIndicator = document.getElementById('micIndicator');
                if (micIndicator) {
                    micIndicator.innerHTML = `
                        <span style="font-size: 20px; animation: pulse 1s infinite;">üî¥</span>
                        <span style="font-weight: 600;">LISTENING - Speak clearly now!</span>
                    `;
                    micIndicator.parentElement.style.background = '#fee2e2';
                    micIndicator.parentElement.style.borderColor = '#dc2626';
                }
            };
            
            recognition.onsoundstart = () => {
                console.log('üîäüîäüîä SOUND DETECTED! Microphone hearing audio! üîäüîäüîä');
            };
            
            recognition.onspeechstart = () => {
                console.log('üó£Ô∏èüó£Ô∏èüó£Ô∏è SPEECH DETECTED! You are speaking! üó£Ô∏èüó£Ô∏èüó£Ô∏è');
            };
            
            recognition.onspeechend = () => {
                console.log('ü§ê Speech ended');
            };
            
            recognition.onresult = (event) => {
                console.log('üì• Got recognition result event!');
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const result = event.results[i];
                    const transcript = result[0].transcript;
                    const confidence = (result[0].confidence * 100).toFixed(1);
                    
                    if (result.isFinal) {
                        finalTranscript = transcript;
                        console.log('üìùüìùüìù FINAL TRANSCRIPT:', transcript, 'confidence:', confidence + '%');
                        console.log('‚úÖ Final speech captured successfully!');
                    } else {
                        lastInterim = transcript;
                        console.log('üîÑ Interim transcript:', transcript, 'confidence:', confidence + '%');
                    }
                }
            };
            
            recognition.onend = async () => {
                console.log('üî¥ Recognition ended');
                console.log('üìä Final transcript to process:', finalTranscript);
                
                pushBtn.style.background = '#0891b2';
                pushBtn.textContent = 'üé§ Click & Speak';
                
                if (finalTranscript.trim()) {
                    console.log('üí¨ Processing user speech:', finalTranscript);
                    addToCallTranscript('user', finalTranscript);
                    updateCallStatus('ü§ñ AI thinking...');
                    
                    await getAIResponse(finalTranscript);
                    finalTranscript = '';
                } else {
                    console.log('‚ö†Ô∏è No speech captured, button ready for retry');
                    updateCallStatus('üé§ Ready - Click button to speak');
                }
            };
            
            recognition.onerror = (event) => {
                console.error('‚ùå Recognition error:', event.error);
                pushBtn.style.background = '#0891b2';
                pushBtn.textContent = 'üé§ Click & Speak (try again)';
                updateCallStatus('‚ùå Error - Click to retry');
            };
            
            // Start recognition
            try {
                console.log('üöÄ Starting MANUAL recognition...');
                recognition.start();
                console.log('‚úÖ Manual start() called - waiting for onstart event...');
            } catch (error) {
                console.error('‚ùå Manual start FAILED:', error);
                pushBtn.textContent = '‚ùå Failed - Click to retry';
            }
        }
        
        function toggleMute() {
            const muteBtn = document.getElementById('muteBtn');
            if (muteBtn.classList.contains('active')) {
                muteBtn.classList.remove('active');
                if (recognition) {
                    try {
                        recognition.start();
                    } catch (e) {}
                }
            } else {
                muteBtn.classList.add('active');
                if (recognition) {
                    try {
                        recognition.stop();
                    } catch (e) {}
                }
            }
        }
        
        function endCallScreen() {
            isCallActive = false;
            
            // Stop all audio
            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {}
            }
            if (synthesis) {
                synthesis.cancel();
            }
            
            // Remove calling screen
            const overlay = document.getElementById('callingOverlay');
            if (overlay) {
                overlay.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => overlay.remove(), 300);
            }
            
            // Reset button
            const callBtn = document.getElementById('callBtn');
            callBtn.classList.remove('call-active');
            callBtn.textContent = 'üìû Call Support';
            callBtn.style.background = '';
            
            updateStatus('Connected ‚Ä¢ Ready to assist');
            addMessage('agent', 'üìû **Call ended.** Thank you for contacting us!');
        }

        function updateStatus(message) {
            document.getElementById('statusBar').textContent = message;
        }
    </script>
</body>
</html>
